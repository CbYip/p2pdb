

### 模块介绍
P2PDB数据库在p2pdb-log之上实现，p2pdb-log是一种用于分布式系统的不可变的、基于操作的无冲突复制数据结构 (CRDT)与Merkle DAG（有向无环图）实现。如果所有 P2PDB 数据库类型都不符合您的需求和/或您需要特定于案例的功能，您可以轻松使用日志模块实现您想要的数据库

#### 术语
节点：每个操作的原子事件作为merkle-dag的一个节点
NODE_CID:节点内容寻址符 hash值,注意该hash值由单个或多个父节点的hash生成,可能会随着merkle-dag的冲突合并而变动
NODE_ID:由客户端cid跟本地表主键自增id生成的id,hash值,唯一且不会变动
Link:包含Name、Hash、Size
DATA:为json数据,存储原子事件的具体内容


### 模块职责
#### 基本原则
1、每个新插入的节点都必须是根节点
2、每个新节点都必须包含上一个根节点（如果存在）
3、pub广播时只需要广播根节点的cid,通过拉取来获取完整的差异节点
4、相同的节点通过设计取重复：每个事件只能有唯一的标识


### 核心实现

#### GSET(Grow-only Set)仅增长集
GSet是一个非常简单的CRDT，p2pdb-log 使用它实现事件日志记录



#### Merkle DAG 
是一种被称为有向无环图的数据结构，p2pdb-log 使用它存储事件的因果关系


#### 仅附加日志
不可变日志，用于存储经过因果关系排序的数据更改条目，此日志为仅附加日志，这意味着只能将数据添加到日志中，而无法重写或删除数据。这样可确保已存储的更改历史记录无法被删除或修改。即使所有节点都被删除数据，仍可通过从不可变日志中恢复完整数据库。

p2pdb-log是一种用于去中心化系统的不可变的、基于操作的无冲突复制数据结构 ( CRDT )。它是一个仅可追加的日志，可用于在 p2p 应用程序中对点之间的可变共享状态进行建模。

日志中的每个条目都保存在 p2pdb 中，子级日志被父级日志所指向形成有向环图，日志可以分叉并重新连接在一起,该模块适用于golang 语言。


           Log A                Log B             
             |                    |
     logA.append("Aone")   logB.append("Bone")  
             |                    |
             v                    v
          +-----+             +-------+
          |"Aone"|             |"Bone"|
          +-----+             +-------+
             |                    |
     logA.append("Atwo")   logB.append("Btwo")
             |                    |
             v                    v
       +-----------+       +---------------+
       |"Aone","Atwo"|       |"Bone","Btwo"|
       +-----------+       +---------------+
             |                    |
             |                    |
       logA.join(logB) <----------+
             |
             v
+---------------------------+
|"Aone","Bone","Atwo","Btwo"|
+---------------------------+

#### 事件顺序
事件在写入Merkle DAG时，可以嵌入一些用于排序的参数，如lamport lock， 向量时钟，版本时钟，merkle-clock, last write win等,
在merge两个并发产生的事件时，用户可根据实际场景选择采用哪一种排序条件作为顺序判断规则,如果内置的排序条件不足以满足实际场景，用户可自行
通过编写排序规则类替换，我们也鼓励用户按照p2pdb开发规范，将排序规则提交为PR为社区做出贡献。 

#### 最终一致性
分布式系统中的最终一致性（EC）是指系统副本之间的状态可能不相同的情况，但是，如果有足够的时间，并且在网络分区、停机、断网和其它意外事件得到
解决之后，系统设计将确保状态在任何节点上都变得相同。基于状态的CRDT的节点修改数据的状态，并将修改结果状态广播给其它对等节点，如果对等节点正确的接收
了同步的数据状态，副本最终会被收敛成相同状态。


#### 相关文档
[merkle-dag1](zh-cn/p2pdb-log/merkle-dag1.md)


#### Merkle Clock 
[详细论文](https://github.com/Rock-liyi/p2pdb/blob/master/doc/zh-cn/merkle-crdt.pdf)

CID 的功能类似于数据块的指纹，主要由加密哈希组成数据本身。我们可以使用此标识符作为唯一且简洁的名称来指向该数据。由于名称是唯一的，我们可以将其用作链接，将基于位置的标识符（如 URL）替换为基于数据本身内容的标识符。

然而，链接不仅仅用于识别特定内容；它们是表示、组织和遍历结构化信息的基本工具。在我们日常生活中的各种对象和系统中——电话簿、书目、思维导图、分类法等等——我们发现数据具有结构，而链接是该结构的关键部分。

### 注意事项

#### 风险注意
如果您耐心看完任何一种逻辑时钟的实现，也许会发现无论任何一种逻辑时钟的实现，都无法严格的保证在并发情况下，事件具有因果关系并且按照真实物理发生的顺序
进行排序，如同狭义相对论指出，我们的时空中的事件并不存在一个始终如一的全序关系，不同的观察者对两个事件谁先发生可能具有不同的看法，仅当事件A是由事件B引起的时候，事件AB才具有一个准确的先后顺序，如果业务场景对于事件物理发生顺序有着强烈的要求，那么你应当考虑选用强一致协议如Raft、Paxos等实现的数据库。p2pdb-log本身仅做具有因果关系的顺序日志记录，当出现冲突时,p2pdb-log会将冲突事件写在相同层级的merkle-dag节点,在p2pdb读取时并发事件交由p2pdb-consistency模块实现具体排序。








